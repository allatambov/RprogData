---
title: "Работа с базами данных с использованием `dplyr`."
author: "Алла Тамбовцева"
output: html_document
---

Библиотека `dplyr` - библиотека для удобной работы с базами данных. С ее помощью можно более быстро получать описание базы данных, сохранять полученные результаты и группировать данные по определенному признаку. Научиться работать с это библиотекой несложно, нужно только понять общую логику, познакомиться с особыми операторами и функциями, а также немного попрактиковаться.

Для начала установим библиотеку и обратимся к ней:

```{r,eval=FALSE}
install.packages("dplyr")
```

```{r,message=FALSE,comment=FALSE}
library(dplyr)
```

Теперь мы готовы к работе. Загрузим таблицу, с которой мы работали на прошлом семинаре.

```{r}
df <- read.csv("http://math-info.hse.ru/f/2018-19/comm-math/marketing.csv")
```

### Основные функции `dplyr` и оператор `%>%`

Некоторые функции, встроенные в библиотеку, похожи на обычные функций, которые мы использовали на прошлом занятии. Например, функция `select()`, которая позволяет выбрать интересующие нас столбцы в базе данных:

```{r}
df_small <- dplyr::select(df, MarketID, Promotion, SalesInThousands)
#View(df_small) 
```

Также с помощью `select()` можем исключить некоторые столбцы, которые нас не интересуют, поставив перед вектором столбцов минус (так же, как и раньше!):

```{r}
df_small2 <- dplyr::select(df, -c(Week, LocationID))
#View(df_small2)
```

Столбцы можно выбирать по названиям, если столбцы идут подряд:

```{r}
df_small3 <- dplyr::select(df, AgeOfStore:Week) # с AgeOfStore по Week
#View(df_small3)
```

Если хотим отобрать интересующие нас наблюдения, нам потребуется другая функция - `filter()`. 

```{r}
medium <- filter(df, MarketSize == "Medium") # фирмы среднего размера
```

Можем прописывать сложные условия, например, выберем фирмы среднего размера, которые находятся на рынке более 5 лет:

```{r}
df2 <- filter(df, MarketSize == "Medium" & AgeOfStore > 5)
```

Казалось бы, зачем использовать библиотеку dplyr, если результаты пока несильно отличаются от того, что мы делали на прошлом занятии без всяких библиотек? На самом деле, смысл использовать ее есть. И сейчас мы переходим к самому интересному.

В библиотеке `dplyr` есть особый оператор `%>%`, который позволяет выполнять операции пошагово. Смысл этого оператора такой: возьми, то, что слева от `%>%` и передай это на вход функции, стоящей справа от `%>%`. Посмотрим на простом примере:

```{r,eval=FALSE}
df %>% View
```

Взять базу `df` и подать ее на вход функции `View`. Как можно заметить, во `View` уже нет ни скобок, ни названия базы, потому что они и не нужны – R и так знает, с чем ему работать.

Рассмотрим другой пример. Возьмем базу `df`, сначала выберем столбцы `MarketID`, `Promotion`, и `SalesInThousands`, а потом запросим несколько первых строк базы:

```{r,eval=FALSE}
df %>% select(MarketID, Promotion, SalesInThousands) %>%
  head %>% View
```

В библиотеке `dplyr` есть несколько других интересных и полезных функций. Например, `arrange()` – функция, которая сортирует базу данных в соответствии со значениями переменной (или переменных), расположенных по возрастанию (если переменная текстовая, то по алфавиту). Отсортируем базу по показателю `SalesInThousands` и посмотрим на первые несколько строк:

```{r}
df %>% arrange(SalesInThousands) %>% head
```

Если нам нужно отсортировать строки по показателю в порядке убывания, то следует внутри `arrange()` дописать функцию `desc()` (сокращение от *descending*):

```{r}
df %>% arrange(desc(SalesInThousands)) %>% head
```

Другая полезная функция – `mutate()` – используется для создания и добавлению в базу данных новой переменной. Создадим переменную `log_sales` – натуральный логарифм числа продаж.

```{r,eval=FALSE}
df %>% mutate(log_sales = log(SalesInThousands))
```

Если теперь мы посмотрим на базу `df` привычным образом, нас будет ждать сюрприз:

```{r,eval=FALSE}
View(df)
```

Переменной `log_income` в базе нет! Почему? Дело в том, что когда мы проделываем что-то с базой с помощью `dplyr` и не сохраняем результат, изменения в самой базе не происходят. Как сохранить изменения? Очень просто: как всегда, сохранить результат в переменную, в которой хранится база:

```{r}
df <- df %>% mutate(log_sales = log(SalesInThousands))
#View(df)
```

Добавлять можно и более одной переменной за раз: достаточно перечислить их через запятую внутри `mutate()`.

### Функции `summarize()`, `group_by()` и `tally()`

Сейчас речь пойдет, пожалуй, о самых полезных функциях `dplyr` :)

При работе с данными мы часто сталкиваемся с тем, что нам нужно получить какую-то сводную информацию по переменным. Для этого существует функция `summarise()`. Попробуем пока получить общее число строк в базе данных:

```{r}
df %>% summarise(total = n())
```

Функция `n()` универсальна, она используется для подсчета элементов. К ней мы еще вернемся.

Теперь сделаем что-нибудь более интересное. Определим минимальное, максимальное и среднее значение числа продаж в этой базе.

```{r}
df %>% summarise(avg_sales = mean(SalesInThousands), 
          min_sales = min(SalesInThousands), 
          max_sales = max(SalesInThousands))
```

Почему R не хочет ничего считать? Потому что в переменно age есть пропущенные значения! Как справиться с этой проблемой? Самое простое и очевидное – удалить `NA` из базы. Но это необязательно. У многих функций в R, работающих с переменными, есть параметр `na.rm`, который позволяет зафиксировать, исключать ли пропущенные значения (*rm - remove*) при подсчете или нет.

```{r}
df %>% summarise(avg_sales = mean(SalesInThousands, na.rm = TRUE), 
          min_sales = min(SalesInThousands, na.rm = TRUE), 
          max_sales = max(SalesInThousands, na.rm = TRUE))
```

Часто необходимо получить сводную информацию не по всем наблюдениям в базе, а по определенной группе. Для этого сначала нужно сгруппировать данные, основываясь на значениях какой-нибудь переменной. Воспользуемся функцией `group_by()` и посмотрим, сколько в базе фирм разных размеров:

```{r}
df %>% group_by(MarketSize) %>% summarise(count = n())
```

Так как у одной фирмы не указан размер и значение не является полноценным пропущенным (`NA`), вместо трех групп фирм мы получили четыре. Поправим:

```{r}
df <- filter(df, MarketSize != "") # удалить строки с "" в MarketSize

df %>% group_by(MarketSize) %>% summarise(count = n())
```

А теперь посмотрим на среднее число продаж разных типов фирм:

```{r}
df %>% group_by(MarketSize) %>% summarise(avg_sales = mean(SalesInThousands, na.rm = TRUE))
```

Число наблюдений можно посчитать и по-другому – с помощью функции `tally()`:

```{r}
df %>% group_by(MarketSize) %>% tally()
```
